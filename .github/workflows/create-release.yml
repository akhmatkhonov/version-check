name: Create release

# Required secrets:
# OV_TRACKOR_AUTOMATION_ACCESS_KEY - Access Key for trackor.onevizion.com
# OV_TRACKOR_AUTOMATION_SECRET_KEY - Secret Key for trackor.onevizion.com

on:
  workflow_dispatch:
  schedule:
    - cron: 0 0 * * SAT

permissions:
  contents: write

env:
  GIT_USERNAME: 'ov-automation'
  GIT_EMAIL: 'github-actions@github.com'
  TRACKOR_URL: https://trackor.onevizion.com

jobs:
  find_and_validate_changes:
    name: Find and validate changes
    runs-on: ubuntu-latest
    outputs:
      create_release: ${{ steps.validate_issue_status.outputs.create_release }}
      issue_rel_notes_json: ${{ toJSON(steps.validate_issue_status.outputs) }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find latest release
        id: find_latest_release
        run: |
          LATEST_RELEASE_REF="$(curl 'https://api.github.com/repos/${{ github.repository }}/releases' -H 'Authorization: Bearer ${{ github.token }}' | jq -r 'first | .tag_name')"
          if [[ "$LATEST_RELEASE_REF" == "null" ]]; then
            echo "No any release found, using first commit from ${{ github.ref }}. Will be initial release"
            LATEST_RELEASE_REF="$(git rev-list --max-parents=0 '${{ github.ref }}' | tail -n 1)"
          fi

          echo "Latest release ref: $LATEST_RELEASE_REF"
          echo "latest_release_ref=$LATEST_RELEASE_REF" >> $GITHUB_OUTPUT

      - name: Find Issue IDs
        id: find_issue_ids
        env:
          ISSUE_IDS_FILE: issue_ids.txt
        run: |
          git cherry -v "${{ steps.find_latest_release.outputs.latest_release_ref }}" '${{ github.ref }}' | while read COMMIT_DESCRIPTION
          do
            COMMIT_ID="$(echo "$COMMIT_DESCRIPTION" | cut -d' ' -f2)"
            ISSUE_ID="$(echo "$COMMIT_DESCRIPTION" | cut -d' ' -f3 | awk '{ if (match($0, /[A-Za-z]{1,32}-[0-9]{1,7}/, m)) { print m[0]; exit }}')"

            if [ -z "$ISSUE_ID" ]; then
              echo "No Issue ID in $COMMIT_DESCRIPTION"
              continue
            fi

            echo "New changes: $COMMIT_ID ($ISSUE_ID)"
            echo "$ISSUE_ID" >> "$ISSUE_IDS_FILE"
          done
          
          let COUNTER=0
          cat "$ISSUE_IDS_FILE" | sort | uniq | while read ISSUE_ID
          do
            let COUNTER++
            echo "issue_id_$COUNTER=$ISSUE_ID" >> $GITHUB_OUTPUT
          done

      - name: Validate Issue statuses
        id: validate_issue_status
        env:
          ISSUE_IDS_FILE: issue_ids.json
          CURL_RESPONSE_FILE: curl_response.txt
        run: |
          cat << 'EOF' > "$ISSUE_IDS_FILE"
          ${{ toJSON(steps.find_issue_ids.outputs) }}
          EOF

          let COUNTER=0
          cat "$ISSUE_IDS_FILE" | jq -r 'to_entries[] | select(.key | startswith("issue_id_")) | .value' | while read ISSUE_ID
          do
            curl \
              -H 'Authorization: Basic ${{ secrets.OV_TRACKOR_AUTOMATION_ACCESS_KEY }}:${{ secrets.OV_TRACKOR_AUTOMATION_SECRET_KEY }}' \
              "$TRACKOR_URL/api/v3/trackor_types/Issue/trackors?fields=VQS_IT_XITOR_NAME,VQS_IT_STATUS&TRACKOR_KEY=$ISSUE_ID" > "$CURL_RESPONSE_FILE"

            ISSUE_SUMMARY="$(cat "$CURL_RESPONSE_FILE" | jq -r 'first | .VQS_IT_XITOR_NAME')"
            ISSUE_STATUS="$(cat "$CURL_RESPONSE_FILE" | jq -r 'first | .VQS_IT_STATUS')"
            echo "$ISSUE_ID: $ISSUE_SUMMARY ($ISSUE_STATUS)"

            if [[ "$ISSUE_STATUS" != "Completed" ]]; then
              echo "::error::Wrong Issue status, should be 'Completed'"
              exit 1
            fi

            let COUNTER++
            echo "issue_rel_notes_$COUNTER=$ISSUE_ID $ISSUE_SUMMARY" >> $GITHUB_OUTPUT
          done

          echo 'All issues have Completed status, allowing to create release'

  create_release:
    name: Create release
    needs: find_and_validate_changes
    runs-on: ubuntu-latest
    steps:
      - name: Get next version
        id: get_next_version
        run: |
          # TODO
          echo "next_version=1.4" >> $GITHUB_OUTPUT

      - name: Format release notes
        id: format_release_notes
        env:
          ISSUE_REL_NOTES_FILE: issue_rel_notes.json
        run: |
          cat << 'EOF' > "$ISSUE_REL_NOTES_FILE"
          ${{ needs.find_and_validate_changes.outputs.issue_rel_notes_json }}
          EOF

          {
            echo 'release_notes_body<<EOF'
            echo 'What's Changed'
            cat "$ISSUE_REL_NOTES_FILE" | jq -r 'to_entries[] | .value' | while read ISSUE_RELEASE_NOTES
            do
              echo "* $ISSUE_RELEASE_NOTES"
            done
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Configure Git
        run: |
          git config --global --replace-all user.name "$GIT_USERNAME"
          git config --global --replace-all user.email "$GIT_EMAIL"

      - name: Create tag
        run: |
          git tag -a '${{ steps.get_next_version.outputs.next_version }}' -m 'Release: ${{ steps.get_next_version.outputs.next_version }}'
          git push --tags origin

      - name: Create release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.event.inputs.new_version }}
          body: ${{ steps.format_release_notes.outputs.release_notes_body }}
