name: Create release
description: 'Create release. Permission required: contents:write'
inputs:
  ov_trackor_automation_access_key:
    description: Access Key for trackor.onevizion.com
    required: true
  ov_trackor_automation_secret_key:
    description: Secret Key for trackor.onevizion.com
    required: true
runs:
  using: composite
  env:
    GIT_USERNAME: 'ov-automation'
    GIT_EMAIL: 'github-actions@github.com'
    TRACKOR_URL: https://trackor.onevizion.com
  steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Find latest release
      id: find_latest_release
      shell: bash
      run: |
        GIT_REF="${{ github.ref }}"
        GIT_BRANCH_NAME="${GIT_REF##refs/heads/}"
        echo "Branch name: $GIT_BRANCH_NAME"
        
        LATEST_RELEASE_REF="$(curl --silent \
          --fail-with-body \
          -H 'Authorization: Bearer ${{ github.token }}' \
          'https://api.github.com/repos/${{ github.repository }}/releases?per_page=1000' \
          | jq -r --arg branchFilter "$GIT_BRANCH_NAME" '[ sort_by(.created_at) | reverse | .[] | select( .target_commitish == $branchFilter ) ] | first | .tag_name')"
        
        LATEST_RELEASE_REF_IS_TAG="true"
        if [[ "$LATEST_RELEASE_REF" == "null" ]]; then
          echo "No any release found, using first commit from ${{ github.ref }}. Will be initial release"
          LATEST_RELEASE_REF="$(git rev-list --max-parents=0 '${{ github.ref }}' | tail -n 1)"
          LATEST_RELEASE_REF_IS_TAG="false"
        fi
        
        echo "Latest release ref: $LATEST_RELEASE_REF (Is Tag: $LATEST_RELEASE_REF_IS_TAG)"
        
        echo "latest_release_ref=$LATEST_RELEASE_REF" >> $GITHUB_OUTPUT
        echo "latest_release_ref_is_tag=$LATEST_RELEASE_REF_IS_TAG" >> $GITHUB_OUTPUT

    - name: Find Issue IDs
      id: find_issue_ids
      shell: bash
      env:
        ISSUE_IDS_FILE: issue_ids.txt
      run: |
        rm -f "$ISSUE_IDS_FILE"
        
        IS_HAVE_NEW_COMMITS="0"
        
        while read COMMIT_DESCRIPTION
        do
          IS_HAVE_NEW_COMMITS="1"
          COMMIT_ID="$(echo "$COMMIT_DESCRIPTION" | cut -d' ' -f2)"
          ISSUE_ID="$(echo "$COMMIT_DESCRIPTION" | cut -d' ' -f3 | awk '{ if (match($0, /[A-Za-z]{1,32}-[0-9]{1,7}/, m)) { print m[0]; exit }}')"
        
          if [ -z "$ISSUE_ID" ]; then
            echo "No Issue ID in $COMMIT_DESCRIPTION"
            continue
          fi
        
          echo "New changes: $COMMIT_ID ($ISSUE_ID)"
          echo "$ISSUE_ID" >> "$ISSUE_IDS_FILE"
        done < <(git cherry -v "${{ steps.find_latest_release.outputs.latest_release_ref }}" '${{ github.ref }}')
        
        echo "is_have_commits=$IS_HAVE_NEW_COMMITS" >> $GITHUB_OUTPUT
        
        if [ "$IS_HAVE_NEW_COMMITS" -eq 0 ]; then
          echo '::notice::No new commits'
        elif [ "$IS_HAVE_NEW_COMMITS" -eq 1 ] && [ -f "$ISSUE_IDS_FILE" ]; then
          COUNTER=1
          while read ISSUE_ID
          do
            echo "issue_id_$COUNTER=$ISSUE_ID" >> $GITHUB_OUTPUT
            (( COUNTER++ ))
          done < <(cat "$ISSUE_IDS_FILE" | sort | uniq)
        fi

    - name: Validate Issue statuses
      id: validate_issue_status
      shell: bash
      if: steps.find_issue_ids.outputs.is_have_commits == '1'
      env:
        ISSUE_IDS_FILE: issue_ids.json
        CURL_RESPONSE_FILE: curl_response.txt
      run: |
        if [[ '${{ runner.debug }}' == '1' ]]; then
          set -x
        fi
        
        cat << 'EOF' > "$ISSUE_IDS_FILE"
        ${{ toJSON(steps.find_issue_ids.outputs) }}
        EOF
        
        export COUNTER=1
        export ALLOW_CREATE_RELEASE=1
        export IS_HAVE_ISSUES=0
        export MAX_MAJOR_VERSION=1
        
        trap 'cat "$CURL_RESPONSE_FILE"' ERR
        
        while read ISSUE_ID
        do
          IS_HAVE_ISSUES="1"
        
          curl --silent \
            --fail-with-body \
            -H 'Authorization: Bearer ${{ inputs.ov_trackor_automation_access_key }}:${{ inputs.ov_trackor_automation_secret_key }}' \
            "$TRACKOR_URL/api/v3/trackor_types/Issue/trackors?fields=VQS_IT_STATUS,Version.TRACKOR_KEY&TRACKOR_KEY=$ISSUE_ID" > "$CURL_RESPONSE_FILE"
        
          ARRAY_LENGTH="$(cat "$CURL_RESPONSE_FILE" | jq -r 'length')"
          if [ "$ARRAY_LENGTH" -gt 1 ]; then
            echo "::error::$ISSUE_ID have multiple versions assigned?"
            cat "$CURL_RESPONSE_FILE"
            ALLOW_CREATE_RELEASE="0"
            continue
          fi
        
          ISSUE_STATUS="$(cat "$CURL_RESPONSE_FILE" | jq -r 'first | .VQS_IT_STATUS')"
          ISSUE_VERSION="$(cat "$CURL_RESPONSE_FILE" | jq -r 'first | ."Version.TRACKOR_KEY"')"
          echo "$ISSUE_ID. Status: [$ISSUE_STATUS], Version: [$ISSUE_VERSION]"
        
          if [[ "$ISSUE_STATUS" != "Completed" ]] && [[ "$ISSUE_STATUS" != "Completion Review" ]]; then
            echo "::error::Wrong $ISSUE_ID status ($ISSUE_STATUS), should be 'Completed' or 'Completion Review'"
            ALLOW_CREATE_RELEASE="0"
            continue
          fi
        
          if ! [[ "$ISSUE_VERSION" =~ ^[0-9]+\. ]]; then
            echo "::error::Wrong $ISSUE_ID version ($ISSUE_VERSION), should starts with number"
            ALLOW_CREATE_RELEASE="0"
            continue
          fi
        
          ISSUE_VERSION_MAJOR="$(echo "$ISSUE_VERSION" | cut -d'.' -f1)"
          MAX_MAJOR_VERSION="$(( ISSUE_VERSION_MAJOR > MAX_MAJOR_VERSION ? ISSUE_VERSION_MAJOR : MAX_MAJOR_VERSION ))"
        
          echo "issue_id_$COUNTER=$ISSUE_ID" >> $GITHUB_OUTPUT
          (( COUNTER++ ))
        done < <(cat "$ISSUE_IDS_FILE" | jq -r 'to_entries[] | select(.key | startswith("issue_id_")) | .value')
        
        if [ "$IS_HAVE_ISSUES" -eq 0 ]; then
          echo '::notice::No issue IDs are found in commits, check commit messages'
          echo "create_release=0" >> $GITHUB_OUTPUT
          exit 1
        elif [ "$ALLOW_CREATE_RELEASE" -eq 1 ]; then
          echo '::notice::All issues have Completed/Completion Review status, allowing to create release'
          echo "create_release=1" >> $GITHUB_OUTPUT
        else
          echo '::notice::Having issues with wrong status/version'
          echo "create_release=0" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "Max major version found: $MAX_MAJOR_VERSION"
        echo "max_major_version_number=$MAX_MAJOR_VERSION" >> $GITHUB_OUTPUT

    - name: Get new version
      id: get_new_version
      shell: bash
      if: steps.validate_issue_status.outputs.create_release == '1'
      run: |
        MAJOR_VERSION_NEW="${{ steps.validate_issue_status.outputs.max_major_version_number }}"
        echo "New major version: $MAJOR_VERSION_NEW"
        
        if [[ "${{ steps.find_latest_release.outputs.latest_release_ref_is_tag }}" == "true" ]]; then
          MAJOR_VERSION_OLD="$(echo '${{ steps.find_latest_release.outputs.latest_release_ref }}' | cut -d'.' -f1)"
          echo "Old major version: $MAJOR_VERSION_OLD"
        
          if [[ "$MAJOR_VERSION_OLD" == "$MAJOR_VERSION_NEW" ]]; then
            echo "::notice::Latest release major version and new major version are the same, so use same major version and just increment minor version"
            MINOR_VERSION_OLD="$(echo '${{ steps.find_latest_release.outputs.latest_release_ref }}' | cut -d'.' -f2)"
            echo "Old minor version: $MINOR_VERSION_OLD"
        
            MINOR_VERSION_NEW="$MINOR_VERSION_OLD"
            (( MINOR_VERSION_NEW++ )) || true
        
            NEW_VERSION="${MAJOR_VERSION_OLD}.${MINOR_VERSION_NEW}"
          else
            echo "::notice::Latest release major version and new major version are different. Old: [$MAJOR_VERSION_OLD], new: [$MAJOR_VERSION_NEW], so use new major version and zero minor"
            NEW_VERSION="${MAJOR_VERSION_NEW}.0"
          fi
        else
          echo "Latest release is not a tag (no releases found), so use new major version and zero minor"
          NEW_VERSION="${MAJOR_VERSION_NEW}.0"
        fi
        
        echo "::notice::New version: $NEW_VERSION"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Fetch and format release notes
      id: fetch_and_format_release_notes
      if: steps.validate_issue_status.outputs.create_release == '1'
      env:
        ISSUE_IDS_FILE: issue_ids.json
        CURL_RESPONSE_FILE: curl_response.txt
        RELEASE_NOTES_BODY_FILE: release_notes_body.txt
      run: |
        if [[ '${{ runner.debug }}' == '1' ]]; then
          set -x
        fi
        
        cat << 'EOF' > "$ISSUE_IDS_FILE"
        ${{ toJSON(steps.validate_issue_status.outputs) }}
        EOF
        
        trap 'cat "$CURL_RESPONSE_FILE"' ERR
        
        export NO_ISSUES_IN_REL_NOTES=1
        
        echo "What's Changed" > "$RELEASE_NOTES_BODY_FILE"
        
        while read ISSUE_ID
        do
          echo "Fetching release notes for $ISSUE_ID"
        
          curl --silent \
            --fail-with-body \
            -H 'Authorization: Bearer ${{ inputs.ov_trackor_automation_access_key }}:${{ inputs.ov_trackor_automation_secret_key }}' \
            "$TRACKOR_URL/api/v3/trackor_types/Issue/trackors?fields=VQS_IT_XITOR_NAME,VQS_IT_RELEASE_NOTES,VQS_IT_DONT_INCLUDE_IN_REL_NOTES&TRACKOR_KEY=$ISSUE_ID" > "$CURL_RESPONSE_FILE"
        
          ISSUE_SKIP_IN_REL_NOTES="$(cat "$CURL_RESPONSE_FILE" | jq -r 'first | .VQS_IT_DONT_INCLUDE_IN_REL_NOTES')"
          if [[ "$ISSUE_SKIP_IN_REL_NOTES" == "0" ]]; then
            # At least one issue has Release notes
            NO_ISSUES_IN_REL_NOTES=0
          fi
        
          ISSUE_SUMMARY="$(cat "$CURL_RESPONSE_FILE" | jq -r 'first | .VQS_IT_XITOR_NAME')"
          ISSUE_REL_NOTES="$(cat "$CURL_RESPONSE_FILE" | jq -r 'first | .VQS_IT_RELEASE_NOTES | sub("(?<escape>[\\`\\*_{}[\\]<>()#+-.!|]{1})"; "\\\(.escape)"; "g")')"
          echo "$ISSUE_ID. Summary: [$ISSUE_SUMMARY], Rel notes escaped: [$ISSUE_REL_NOTES]"
        
          ISSUE_REL_NOTES="$(echo "${ISSUE_REL_NOTES}" | awk '{if ($0 == "") {print "    "} else {print "    _" $0 "_"}}')"
        
          # Two spaces at the end are required to have rel.notes properly rendered in VizionHub UI in platform
          echo "* [$ISSUE_ID]($TRACKOR_URL/trackor_types/Issue/trackors.do?key=$ISSUE_ID) $ISSUE_SUMMARY  " >> "$RELEASE_NOTES_BODY_FILE"
          echo "${ISSUE_REL_NOTES}" >> "$RELEASE_NOTES_BODY_FILE"
        done < <(cat "$ISSUE_IDS_FILE" | jq -r 'to_entries[] | select(.key | startswith("issue_id_")) | .value')
        
        if [ "$NO_ISSUES_IN_REL_NOTES" -eq 1 ]; then
          echo 'No issues with Release notes'
          echo 'No changes to mention here' > "$RELEASE_NOTES_BODY_FILE"
        fi
        
        echo "release_notes_body_json<<EOF" >> $GITHUB_OUTPUT
        jq --rawfile data "$RELEASE_NOTES_BODY_FILE" '{body: $data}' <<< '{}' >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Configure Git
      if: steps.validate_issue_status.outputs.create_release == '1'
      run: |
        git config --global --replace-all user.name "$GIT_USERNAME"
        git config --global --replace-all user.email "$GIT_EMAIL"

    - name: Create tag
      if: steps.validate_issue_status.outputs.create_release == '1'
      run: |
        git tag -a '${{ steps.get_new_version.outputs.new_version }}' -m 'Release: ${{ steps.get_new_version.outputs.new_version }}'
        git push --tags origin

    - name: Create release
      uses: ncipollo/release-action@v1
      if: steps.validate_issue_status.outputs.create_release == '1'
      with:
        tag: ${{ steps.get_new_version.outputs.new_version }}
        body: ${{ fromJson(steps.fetch_and_format_release_notes.outputs.release_notes_body_json).body }}
